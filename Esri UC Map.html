<!-- Put these just before your <style> -->
<!-- Google Fonts removed; using websafe Tahoma -->
<!-- Full-bleed section that SCROLLS with the page -->
<div id="uc-scroll-hero" class="uc-fullbleed">
  <!-- Inline-hide prevents initial flash before CSS loads -->
  <div id="uc-canvas-mount" style="opacity:0"></div>

  <!-- Search bar (top-center) -->
  <div class="uc-searchbar" role="search">
    <svg class="uc-search-icon" viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="11" cy="11" r="7" fill="none" stroke="currentColor" stroke-width="2"></circle>
      <line x1="16.5" y1="16.5" x2="21" y2="21" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
    </svg>
    <input id="uc-search-input" type="search" placeholder="" aria-label="Search previous UCs" />
    <!-- Centered PNG placeholder -->
    <img class="uc-search-placeholder-img" src="https://github.com/cautionchris/esriucportal/blob/main/Esri%20UC%20Search.png?raw=true" alt="" aria-hidden="true" />
  </div>

  <!-- Orb pop menu (created once, reused) -->
  <div id="uc-orb-menu" class="uc-orb-menu" hidden>
    <!-- remove glyph; we’ll draw the X via CSS -->
    <button class="uc-menu-close" aria-label="Close"></button>
    <div class="uc-menu-year">YEAR</div>
    <div class="uc-menu-desc">Description here…</div>
    <a class="uc-menu-link" href="#" target="_blank" rel="noopener">Find more </a>

    <!-- NEW: right-side carousel -->
    <div class="uc-menu-carousel" id="uc-menu-carousel">
      <div class="uc-carousel-track" id="uc-carousel-track"></div>
      <button class="uc-carousel-btn prev" type="button" aria-label="Previous slide">&#10094;</button>
      <button class="uc-carousel-btn next" type="button" aria-label="Next slide">&#10095;</button>
      <div class="uc-carousel-dots" id="uc-carousel-dots"></div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

<style>
:root {
  /* Use Tahoma with sensible fallbacks */
  --uc-font: Tahoma, Verdana, "Segoe UI", Arial, sans-serif;
  --menu-scale: 1;
  --uc-close-size: 48px;      /* adjust this to change the X size */
  --uc-close-offset: 8px;     /* distance from top/right */
  --uc-pad-bottom: 60px; /* increase this to add more bottom padding */
}

/* Then apply */
.uc-fullbleed { font-family: var(--uc-font); }
.uc-menu-year { font-family: var(--uc-font); font-weight: 800; }

  .uc-fullbleed {
    --uc-extra-bottom: 79px; /* reduced by 10% */
    position: relative;
    left: 50%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    width: 100vw;
    min-height: calc(100vh + var(--uc-extra-bottom)); 
    height: auto; 
    padding-bottom: var(--uc-extra-bottom); 
    overflow: hidden;
    font-family: var(--uc-font);
    /* Responsive bg image with a tint on top */
    background-image:
      image-set(
        url("https://github.com/cautionchris/esriucportal/blob/main/Esri%20UC%20Map%20Blue%20Background%20Hex.png?raw=true") 1x,
        url("https://github.com/cautionchris/esriucportal/blob/main/Esri%20UC%20Map%20Blue%20Background%20Hex.png?raw=true") 2x
      );
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
  }
  /* Optional: ultrawide */
  @media (min-aspect-ratio: 21/9) {
    .uc-fullbleed {
      background-image:
        linear-gradient(to bottom, rgba(255,120,0,0.55), rgba(255,180,60,0.55)),
        image-set(
          url("./img/uc-bg-ultrawide-1440.webp") 1x,
          url("./img/uc-bg-ultrawide-2880.webp") 2x
        );
      background-position: center 40%;
    }
  }
  #uc-canvas-mount { 
    position: absolute; 
    inset: 0; 
    opacity: 0;              /* hidden at first */
    transition: none;        /* do NOT animate to 0 on load */
    z-index: 1;
  }

  /* Fade in only when stage class is added (animate 0 -> 1) */
  .uc-fullbleed.uc-stage-1 #uc-canvas-mount {
    opacity: 1 !important;             /* override inline opacity:0 */
    transition: opacity 600ms ease-out;
  }

  /* Hide search bar until fade starts, then let its own opacity rules take over */
  .uc-fullbleed:not(.uc-stage-1) .uc-searchbar {
    opacity: 0 !important;
    pointer-events: none;
  }

  #uc-canvas-mount canvas {
    width: 100% !important; height: 100% !important; display: block; background: transparent !important;
  }

  /* Pop menu (match 333 lined up.html) */
  .uc-orb-menu {
    position: absolute;
    /* anchor at -40% so the extra width extends to the right */
    transform: translate(-40%, -100%) translateZ(0); /* promote to GPU */
    will-change: transform, opacity;                 /* pre-allocate layer */
    backface-visibility: hidden;
    contain: layout paint;                           /* isolate layout/paint */
    box-sizing: border-box; /* include padding in width */
    width: calc((clamp(560px, 64vw, 1080px) / var(--menu-scale)) * 1.25);
    background: #1f2023;
    border: none;
    color: #fff;
    border-radius: 6px;

    /* tighter gutters so text can reach the edge */
    --uc-pad-left: 52px;
    --uc-pad-right: 28px;          /* was 306px */
    --uc-header-pad-left: 50px;

    padding: 0
      calc(var(--uc-pad-right) / var(--menu-scale))
      calc(var(--uc-pad-bottom) / var(--menu-scale))   /* bottom padding */
      calc(var(--uc-pad-left) / var(--menu-scale));
    line-height: 1.5;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 20;
    display: grid;
    grid-template-columns: 1fr minmax(220px, 30%); /* was minmax(260px, 40%) */
    gap: 16px;
    align-items: start;
    grid-auto-flow: row dense; /* pack items into earliest available cells */
  }
  .uc-orb-menu.show {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    /* keep the same anchor here too */
    transform: translate(-40%, -100%);
  }
  /* Add this to allow fade-out */
  .uc-orb-menu.hiding {
    opacity: 0;
    visibility: visible;   /* keep visible until fade finishes */
    pointer-events: none;
  }

  /* Optional: more bottom padding on small screens */
  @media (max-width: 820px) {
    .uc-orb-menu { --uc-pad-bottom: 56px; }
  }

  /* Header bar (white rectangle with blue text) */
  .uc-menu-year {
    background: #ffffff;
    color: #0D79BF;
    font-weight: 800;
    font-size: clamp(24px, 3.6vw, 48px);
    line-height: 1.5;
    letter-spacing: 0.2px;
    padding: 12px calc(var(--uc-pad-right) / var(--menu-scale)) 12px var(--uc-header-pad-left);
    margin: 0 calc(-1 * (var(--uc-pad-right) / var(--menu-scale))) 14px calc(-1 * (var(--uc-pad-left) / var(--menu-scale)));
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    border-top-left-radius: 6px;
    border-top-right-radius: 6px;
    font-family: var(--uc-font);
    grid-column: 1 / -1;
    grid-row: 1;
  }

  /* Description + list styling to match other file */
  .uc-menu-desc {
    margin: 0 0 10px 0; /* was 24px */
    font-size: clamp(18px, 2.2vw, 28px);
    line-height: 1.8;
    grid-column: 1;
    grid-row: 2;
  }
  .uc-menu-desc ul { list-style: none; padding: 0; margin: 0; }
  .uc-menu-desc li {
    margin: 18px 0;
    line-height: 1.7;
  }
  .uc-menu-desc li a {
    font-style: italic;
    color: #97F3FF;
    text-decoration: underline;
    font-size: 36px; /* fix unit so Safari doesn’t drop this decl */
  }
  .uc-menu-desc li.uc-highlight {
    font-weight: 100;
    font-size: clamp(24px, 3.2vw, 45px);
    line-height: 1.7;
    color: #fff;
  }

  .uc-menu-link {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 8px 18px;    
    background-color: #1d4ed8;
    color: #fff;
    border-radius: 6px;
    font-weight: 800;
    /* bigger CTA text */
    font-size: clamp(18px, 2.2vw, 28px);
    text-decoration: none;
    box-shadow: 0 2px 0 rgba(0,0,0,0.15) inset;
    transition: background-color .2s ease, transform .05s ease;
    margin-top: -6px;     /* lift upward (overrides grid row gap) */
    grid-column: 1;
    grid-row: 3;
    align-self: start;
    line-height: 1.2;     /* tighter text box */
  }
  .uc-menu-link::after {
    content: "";
    display: inline-block;
    width: 0.65em;
    height: 0.65em;
    margin-left: 8px;
    border-right: 0.16em solid currentColor;
    border-top: 0.16em solid currentColor;
    transform: rotate(45deg);
    vertical-align: -0.1em;
  }
  .uc-menu-link:hover { background-color: #67e8f9; transform: scale(1.05); }

  .uc-menu-link {
    /* shrink the visual box */
    padding: 6px 12px;          /* was 8px 18px */
    inline-size: fit-content;   /* shrink to text width */
    justify-self: start;        /* avoid grid stretching */
  }

  /* tighten the arrow spacing and size a bit */
  .uc-menu-link::after {
    margin-left: 6px;           /* was 8px */
    width: 0.55em; height: 0.55em;
    border-right: 0.14em solid currentColor;
    border-top: 0.14em solid currentColor;
  }

  @media (max-width: 820px) {
    .uc-menu-link {
      padding: 6px 10px;
      inline-size: fit-content;
    }
  }

  @media (min-width: 1024px) {
    .uc-menu-link { margin-top: 15px; }
  }

  .uc-menu-close {
    position: absolute;
    top: calc(var(--uc-close-offset) / var(--menu-scale));
    right: calc(var(--uc-close-offset) / var(--menu-scale));
    background: none;
    border: none;
    color: #0D79BF;
    font-weight: 1000;
    cursor: pointer;
    z-index: 11;
    width:  calc(var(--uc-close-size) / var(--menu-scale));
    height: calc(var(--uc-close-size) / var(--menu-scale));
    line-height: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0; /* hide any text content; use CSS-only icon */
  }
  .uc-menu-close::before,
  .uc-menu-close::after {
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    width: 60%;
    height: 7px;
    background: currentColor;
    border-radius: 2px;
    transform-origin: center;
  }
  .uc-menu-close::before { transform: translate(-50%, -50%) rotate(45deg); }
  .uc-menu-close::after  { transform: translate(-50%, -50%) rotate(-45deg); }
  .uc-menu-close:hover { opacity: 0.85; }

  .uc-searchbar {
    position: absolute;
    top: 100px;              
    left: 50%;
    transform: translateX(-50%);
    z-index: 12;               
    width: min(328px, 45.5vw); 
    opacity: 0.35;            
    transition: opacity .2s ease, width .25s ease; /* add width transition */
  }

  /* Hide the text placeholder; we’ll show the PNG instead */
  .uc-searchbar input::placeholder {
    color: transparent;
  }

  /* Centered PNG placeholder inside the oval */
  .uc-search-placeholder-img {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    height: 18px;              /* adjust to fit your art */
    max-width: 70%;
    opacity: 0.85;
    pointer-events: none;
    transition: opacity .15s ease;
  }

  /* Hide the PNG once the user focuses or types */
  .uc-searchbar input:focus ~ .uc-search-placeholder-img,
  .uc-searchbar input:not(:placeholder-shown) ~ .uc-search-placeholder-img {
    opacity: 0;
  }

  /* Keep text centered until typing, then left-align */
  .uc-searchbar input { text-align: center; }
  .uc-searchbar input:not(:placeholder-shown) { text-align: left; }

  .uc-searchbar:hover {
    opacity: 0.35;                 /* hover only changes opacity */
  }
  .uc-searchbar:focus-within {
    opacity: 1;
    width: 200px;               /* shrink only when focused (clicked) */
  }

  .uc-searchbar input {
    width: 100%;
    height: clamp(38px, 3.1vh, 28px);  
    border-radius: 999px;            
    background: transparent;
    border: 2px solid rgba(255,255,255,0.5); 
    color: #fff;
    font-family: var(--uc-font);
    font-size: clamp(12px, 1.4vw, 16px);
    padding: 0 20px;
    padding-left: 32px;        
    text-align: center;
    outline: none;
  }

  .uc-searchbar input::placeholder {
    color: rgba(255,255,255,0.85);
  }

  .uc-search-icon {
    position: absolute;
    left: 12px;                 /* adjusted left offset */
    top: 50%;
    transform: translateY(-50%);
    width: 16px;                /* smaller icon: was 22px */
    height: 16px;               /* smaller icon: was 22px */
    color: rgba(255,255,255,0.85);
    pointer-events: none;
  }

  @media (max-width: 820px) {
    .uc-searchbar { top: 42px; width: min(442px, 59.8vw); } /* Mobile width also 35% shorter: 680px→442px, 92vw→59.8vw */
  }

  /* On click/focus: caret/text start at left, right of the icon */
  .uc-searchbar:focus-within input {
    text-align: left;
    padding-left: calc(12px + 16px + 8px); /* icon left + icon width + gap = 36px */
  }

  /* If you want it always left-aligned (even before typing), use this override instead: */
  /*
  .uc-searchbar input {
    text-align: left;
    padding-left: calc(12px + 16px + 8px);
  }
  */

  /* Carousel */
  .uc-menu-carousel {
    position: relative;
    width: 100%; /* was 90% */
    aspect-ratio: 3 / 3;           /* keeps a nice box; adjust as needed */
    overflow: hidden;
    border-radius: 6px;
    background: rgba(255,255,255,0.06);
    grid-column: 2;
    grid-row: 2 / span 2;   /* start right under header, next to desc+button */
    align-self: start;      /* pin to top of its grid area */
    top: 74px;              /* was auto; increase/decrease to taste */
    margin-top: 0;
    transform-origin: right bottom;      /* anchor scaling at bottom-left */
    transform: scale(1.15);              /* adjust to taste */
    transition: transform 200ms ease;   /* optional */
  }
  .uc-carousel-track {
    display: flex;
    width: 100%;
    height: 100%;
    transform: translateX(0%);
    transition: transform 450ms ease;
  }
  .uc-carousel-track img {
    flex: 0 0 100%;
    width: 100%;
    height: 100%;
    object-fit: cover;
    user-select: none;
    pointer-events: none;
  }
  .uc-carousel-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0,0,0,0.35);
    color: #fff;
    border: 0;
    border-radius: 4px;
    width: 36px;
    height: 36px;
    line-height: 36px;
    text-align: center;
    cursor: pointer;
  }
  .uc-carousel-btn.prev { left: 8px; }
  .uc-carousel-btn.next { right: 8px; }
  .uc-carousel-dots {
    position: absolute;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    display: flex; gap: 6px;
  }
  .uc-carousel-dots button {
    width: 8px; height: 8px; border-radius: 50%;
    border: 0; background: rgba(255,255,255,0.5);
    cursor: pointer;
  }
  .uc-carousel-dots button.active { background: #fff; }

  /* Stack on small screens */
  @media (max-width: 820px) {
    .uc-orb-menu {
      grid-template-columns: 1fr;
      grid-auto-flow: row;
    }
    .uc-menu-carousel {
      grid-column: 1;
      grid-row: auto;
      aspect-ratio: 16 / 9;
      top: 8px;
    }
  }

  @media (max-width: 820px) {
    .uc-menu-link {
      margin-top: -4px;
      padding: 8px 16px;
    }
  }

  /* Override "Find more" button colors */
  .uc-menu-link { 
    background-color: #2083C5; /* normal */
    outline: 2px solid #2083C5; 
    color: #fff;
  }
  .uc-menu-link:hover { 
    background-color: #38bdf8; /* hover */
  }
  .uc-menu-link:active { 
    background-color: #2083C5; /* pressed */
    transform: scale(0.98);
  }
  .uc-menu-link:focus-visible {
    outline: 2px solid #facc15; 
    outline-offset: 2px;
  }
</style>

<script>
/* --- sprites for the blue orbs --- */
const SPRITES = {
  "2026": "https://github.com/cautionchris/esriucportal/blob/main/20263d.png?raw=true",
  "2020": "https://github.com/cautionchris/esriucportal/blob/main/20203d.png?raw=true",
  "2021": "https://github.com/cautionchris/esriucportal/blob/main/20213d.png?raw=true",
  "2022": "https://github.com/cautionchris/esriucportal/blob/main/20223d.png?raw=true",
  "2023": "https://github.com/cautionchris/esriucportal/blob/main/20233d.png?raw=true",
  "2024": "https://github.com/cautionchris/esriucportal/blob/main/20243d.png?raw=true",
  "2025": "https://github.com/cautionchris/esriucportal/blob/main/2025new3d.png?raw=true"
};

/* Textures & logo */
const SPHERE_TEXTURE_URL = "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere222.png?raw=true";
const UC_LOGO_URL       = "https://github.com/cautionchris/esriucportal/blob/main/Esri%20UC%20Logo_1.png?raw=true";

// Per-orb "lit" sphere textures (replace with your PNGs)
const SPHERE_LIT_TEXTURES = {
  "2026": "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere2026.png?raw=true",
  "2020": "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere2020.png?raw=true",
  "2021": "ttps://github.com/cautionchris/esriucportal/blob/main/Sphere2021.png?raw=true",
  "2022": "ttps://github.com/cautionchris/esriucportal/blob/main/Sphere2022fxx.png?raw=true",
  "2023": "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere2023.png?raw=true",
  "2024": "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere2024.png?raw=true",
  "2025": "https://github.com/cautionchris/esriucportal/blob/main/EsriBlueSphere2025.png?raw=true",
};

// Add: always-on overlay for the 2026 orb
const ORB_2026_OVERLAY_URL = "https://github.com/cautionchris/esriucportal/blob/main/Coming%20soon.png?raw=true"; // TODO: set your PNG
let ORB_2026_ROT_DEG_PER_SEC = 18; // rotation speed (deg/sec). Set 0 to stop.
// Scale for the "Coming soon" PNG over the 2026 orb: 1.0 = fits orb, >1 larger, <1 smaller
let ORB_2026_OVERLAY_SCALE = 1.25;

/* Per-year hover overlay videos (edit these URLs) */
const OVERLAY_VIDEO_URLS = {
  "2026": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2019.mp4", // TODO: point to 2026 video
  "2020": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2020fix.mp4",
  "2021": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-User-Conference-2021.mp4",
  "2022": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2022.mp4",
  "2023": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2023-Recapfix.mp4",
  "2024": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2024.mp4",
  "2025": "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Esri-UC-2025.mp4"
};

/* UC logo adjustments (relative to sphere radius) */
const UC_LOGO_SCALE = 1.13;
const UC_LOGO_Y_OFFSET = 0.04; 

/* Desktop layout (moved inward) */
const DESKTOP_LAYOUT = {
  sphere: { cx: 0.50, cy: 0.58, r: 0.24 },
  nodes: {
    "2026": [0.35, 0.43],
    "2020": [0.34, 0.69],
    "2021": [0.46, 0.89],
    "2022": [0.63, 0.80],
    "2023": [0.66, 0.58],
    "2024": [0.63, 0.33],
    "2025": [0.50, 0.29] 
  }
};

/* MOBILE: pulled inward so they’re not so spread out (2025 unchanged) */
const MOBILE_LAYOUT = {
  sphere: { cx: 0.50, cy: 0.56, r: 0.33 },
  nodes: {
    "2026": [0.38, 0.52],
    "2020": [0.36, 0.68],
    "2021": [0.26, 0.84],
    "2022": [0.58, 0.84],
    "2023": [0.64, 0.66],
    "2024": [0.62, 0.42],
    "2025": [0.34, 0.23]
  }
};

/* Connections: previous set + requested new links */
const CONNECTIONS = {
  "2026": ["2020", "2021", "2023", "2025", "2022"],
  "2020": ["2026", "2021", "2022", "2024", "2025"],
  "2021": ["2026", "2020", "2022", "2024", "2025"],
  "2022": ["2020", "2021", "2023", "2025", "2026"],
  "2023": ["2026", "2022", "2024", "2025"],
  "2024": ["2020", "2021", "2023", "2025"],
  "2025": ["2026", "2022", "2023", "2024", "2021", "2020"]
};


const MENU_PLACEMENTS = {
  "2022": { tx:  13, ty: 55, dx:  70, dy:   10 }, 
  "2023": { tx:  15, ty: 50, dx:  70, dy:   0 }, 
  "2024": { tx:  -15, ty: 40, dx:  30, dy:   -75 },
  "2025": { tx: -40, ty: 40, dx:  -30, dy:  -10 }, 
  "2026": { tx: -35, ty: 30, dx: -30, dy: 40 },
  "2020": { tx: -35, ty:  37, dx: -55, dy:   0 }, 
  "2021": { tx: -30, ty: 50, dx: -85, dy: 20 } // Move further left and up
};

/* Mobile-specific menu placements (tune as needed) */
const MOBILE_MENU_PLACEMENTS = {
  "2026": { tx: -50, ty: -110, dx: -10, dy:  0 },
  "2020": { tx: -50, ty: -110, dx:  -8, dy:  0 },
  "2021": { tx: -50, ty: -110, dx: -16, dy:  0 },
  "2022": { tx: -50, ty: -110, dx:  10, dy:  0 },
  "2023": { tx: -50, ty: -110, dx:  12, dy:  0 },
  "2024": { tx: -50, ty: -110, dx:   8, dy:  0 },
  "2025": { tx: -50, ty: -120, dx: -12, dy: -4 }
};

const YEAR_INFO = {
  "2026": { desc: "Highlights", link: "https://www.esri.com/en-us/about/events/uc" },
  "2020": { desc: "Highlights", link: "https://mediaspace.esri.com/channel/2020%2BEsri%2BUser%2BConference/244741502" },
  "2021": { desc: "Highlights", link: "https://www.esri.com/about/newsroom/announcements/2021-esri-user-conference-highlights" },
  "2022": { desc: "Highlights", link: "https://www.esri.com/about/newsroom/announcements/2022-esri-user-conference-highlights" },
  "2023": { desc: "Highlights", link: "https://www.esri.com/about/newsroom/announcements/2023-esri-user-conference-highlights" },
  "2024": { desc: "Highlights", link: "https://www.esri.com/en-us/about/events/uc/agenda/archive/2024" },
  "2025": { desc: "Highlights", link: "https://www.esri.com/arcgis-blog/products/arcgis-enterprise/announcements/arcgis-enterprise-at-uc-2025-11-highlights-that-stood-out" }
};

// Add: three descriptor links per year (edit URLs/text per year)
const YEAR_DESC_ITEMS = {
  "2026": [
    { text: "ArcGIS Living Atlas of the World", href: "https://livingatlas.arcgis.com" },
    { text: "ArcGIS for Microsoft 365", href: "https://www.esri.com/en-us/arcgis/products/arcgis-for-microsoft-365/overview" },
    { text: "Tackling Climate Change on a National Scale", href: "https://www.esri.com/en-us/about/esri-green" }
  ],
  "2020": [
    { text: "ArcGIS Living Atlas of the World", href: "https://livingatlas.arcgis.com" },
    { text: "ArcGIS for Microsoft 365", href: "https://www.esri.com/en-us/arcgis/products/arcgis-for-microsoft-365/overview" },
    { text: "Tackling Climate Change on a National Scale", href: "https://www.esri.com/en-us/about/esri-green" }
  ],
  // add entries for 2021–2025...
};
// Fallback if a year is missing
const DEFAULT_DESC_ITEMS = [
  { text: "ArcGIS Living Atlas of the World", href: "https://livingatlas.arcgis.com" },
  { text: "ArcGIS for Microsoft 365", href: "https://www.esri.com/en-us/arcgis/products/arcgis-for-microsoft-365/overview" },
  { text: "Tackling Climate Change on a National Scale", href: "https://www.esri.com/en-us/about/esri-green" }
];

/* --------- Globals & tunables (responsive) --------- */
const BG_FROM = [255, 120, 0], BG_TO = [255, 180, 60];

// NEW: sphere fade timing
let STAGE1_T0 = 0;                 // set when fade starts (after 1s)
const SPHERE_FADE_MS = 1500;       // 1.5s sphere fade

// Add: 2025 pulse overlay config + image handle
const PULSE_2026 = {
  url: "https://raw.githubusercontent.com/cautionchris/esriucportal/main/Star1.png",
  base: 1.05,
  min: 0.15,
  max: .50,
  secs: .53,
  gapSecs: 4,
  alpha: 1,
  hold: .65,
  delaySecs: 1,                   // NEW: delay before first appearance
  anchor: { dx: -0.72, dy: 0.72 } // bottom-left
};

// NEW: second star (top-right of the same orb)
const PULSE_2026_TR = {
  base: 1.05,
  min: 0.15,
  max: .60,
  secs: .53,
  gapSecs: 4.5,
  alpha: .95,
  hold: .55,
  delaySecs: 1,                   // NEW: same delay
  anchor: { dx: 0.72, dy: -0.72 } // top-right
};

const PULSE_YEAR = "2025";

let orb2026PulseImg = null;
let orb2026PulseReady = false; // NEW

/* Connector styling */
const CONNECTOR_COLOR = '255,255,255'; // RGB only
let CONNECTOR_ALPHA = 0.5;           // 0.0 (invisible) → 1.0 (opaque)

// Popup connector animation
let connectorProgress = 0;            // 0 → 1 length along line
const CONNECTOR_GROW_IN  = 0.18;      // speed in
const CONNECTOR_GROW_OUT = 0.20;      // speed out

// Cache last known endpoints so fade-out doesn’t jump to (0,0)
const connectorCache = { orb: { x: 0, y: 0 }, menu: { x: 0, y: 0 } };

/* BIGGER orbs */
let DOT_R = 45, HOVER_R = DOT_R + 10;       // desktop defaults; overridden in responsive
let LINE_WEIGHT = 2.0, LINE_ALPHA = 81;     // a bit thicker to match size

const ORBIT_AMP = 12, ORBIT_FREQ = 0.18;
const NOISE_AMP = 6, NOISE_SPEED = 0.00035;
const SMOOTH = 0.06;

/* Hover overlay (video) */
const OVERLAY_FADE_IN = 0.08;
const OVERLAY_FADE_OUT = 0.05;
let overlayAlpha = 0;      // keep for compatibility (mirrors "in" alpha)
let overlayScale = 0.92;   // keep for compatibility (mirrors "in" scale)
// Scale animation: separate targets/speeds for in vs out
const OVERLAY_SCALE_IN_TARGET  = 1.00;
const OVERLAY_SCALE_OUT_TARGET = 0.60; // smaller when fading out (was 0.92)
const OVERLAY_SCALE_IN_SPEED   = 0.10; // faster in
const OVERLAY_SCALE_OUT_SPEED  = 0.20; // faster out
let overlayAnchor = { x: 0, y: 0 }; // keep for compatibility (mirrors "in" anchor)

/* Two-layer overlay state: "in" (fading in) and a queue of "fading out" */
const overlayIn  = { label: null, entry: null, alpha: 0, scale: OVERLAY_SCALE_OUT_TARGET, anchor: { x: 0, y: 0 } };
const fadingOut = []; // array of { label, entry, alpha, scale, anchor:{x,y} }

/* Keep last position for true fade-out OR keep fixed while menu is open */
let menuPinnedNode = null; // <— NEW: pin overlay to this node while menu shows

/* Drag/tug */
const TOUCH_DIST_MULT = 2.1;
const OFFSET_RETURN = 0.10;
const LINE_TUG_CURVE = 0.35;
let MAX_DRAG_DIST = 72;
let MAX_OFFSET = 36;
const DRAG_RESP = 0.18;
const DRAG_DEADZONE = 8;

const MOBILE_BREAK = 0.70;
let LAYOUT = DESKTOP_LAYOUT;
let IS_MOBILE = false; // global mobile flag
let MENU_SCALE = 0.45;  // 75% smaller (0.25x)
// No vertical shift; keep everything where it is
const CONTENT_OFFSET_Y = 0;
let EXTRA_BOTTOM = 0; // pixels read from CSS var
// Scale all sizes from a reference (design) height so they grow/shrink with viewport
let UNIT_SCALE = 1;

function readExtraBottom() {
  if (!host) return;
  const v = getComputedStyle(host).getPropertyValue('--uc-extra-bottom').trim();
  const n = parseInt(v, 10);
  EXTRA_BOTTOM = Number.isFinite(n) ? n : 0;
}

/* Overlay video (reused for any orb) */
// Cache one <video> per year so switching is instant
const OVERLAY_VIDEO_CACHE = new Map(); // label -> { video, ready }
let currentOverlayLabel = null;
let currentOverlayEntry = null;
let overlayVideo = null, overlayVideoReady = false; // kept for compatibility
// Offscreen buffer for Safari-friendly alpha compositing
let overlayBuffer = document.createElement('canvas');
let overlayBufCtx = overlayBuffer.getContext('2d', { alpha: true });

/* Sphere/Logo */
let sphereImg = null, ucLogo = null;
// Cache for lit sphere images
const SPHERE_LIT_CACHE = new Map();
function preloadLit(url, key) {
  if (!url || SPHERE_LIT_CACHE.has(key)) return;
  const img = new Image();
  img.decoding = "async";
  img.crossOrigin = "anonymous";
  img.referrerPolicy = "no-referrer";
  img.onload = async () => {
    try { await img.decode(); } catch {}
    const rec = { img, ready: true, bmp: null, bmpSize: 0 };
    SPHERE_LIT_CACHE.set(key, rec);
    prepareLitBitmap(key); // pre-scale for current viewport
  };
  img.onerror = () => SPHERE_LIT_CACHE.set(key, { img: null, ready: false, bmp: null, bmpSize: 0 });
  SPHERE_LIT_CACHE.set(key, { img: null, ready: false, bmp: null, bmpSize: 0 });
  img.src = url;
}

// Compute current sphere diameter (px)
function computeSphereDiameter() {
  const baseH = window.innerHeight;
  const r = Math.min(width, baseH) * LAYOUT.sphere.r;
  return r * 2;
}

async function prepareLitBitmap(key) {
  const rec = SPHERE_LIT_CACHE.get(key);
  if (!rec || !rec.img || !rec.ready) return;
  if (!("createImageBitmap" in window)) return; // skip if unsupported
  const d = Math.round(computeSphereDiameter());
  // Reuse if already prepared for this size
  if (rec.bmp && rec.bmpSize && Math.abs(rec.bmpSize - d) < 2) return;
  try {
    if (rec.bmp && rec.bmp.close) { try { rec.bmp.close(); } catch {} }
    const bmp = await createImageBitmap(rec.img, {
      resizeWidth: d,
      resizeHeight: d,
      resizeQuality: "high"
    });
    rec.bmp = bmp;
    rec.bmpSize = d;
  } catch {}
}

function prepareAllLitBitmaps() {
  Object.keys(SPHERE_LIT_TEXTURES).forEach(k => prepareLitBitmap(k));
}

/* Overlay size */
let OVERLAY_SIZE = 150; // larger to match bigger orbs

/* p5 + DOM */
let nodes = [], hovered = null, draggingNode = null, draggingActive = false, dragStart = null, touchedNode = null, host, cnv;
const SPRITE_CACHE = new Map();
let menuEl, menuCloseEl, menuYearEl, menuDescEl, menuLinkEl;
let menuCarouselEl, menuCarouselTrackEl, menuCarouselDotsEl;
let carouselIdx = 0, carouselTimer = null;
const CAROUSEL_INTERVAL_MS = 3500;

/* --- sprites for the blue orbs --- */
const YEAR_GALLERY = {
  "2026": [
    "https://picsum.photos/id/1015/800/600",
    "https://picsum.photos/id/1005/800/600",
    "https://picsum.photos/id/1003/800/600"
  ],
  "2020": [
    "https://picsum.photos/id/1025/800/600",
    "https://picsum.photos/id/1024/800/600"
  ],
  // add 2021–2025 as desired...
};
const DEFAULT_GALLERY = [
  "https://picsum.photos/id/1035/800/600",
  "https://picsum.photos/id/1040/800/600"
];

/* ---------- helpers ---------- */
function preloadSprite(url) {
  if (!url || SPRITE_CACHE.has(url)) return;
  const img = new Image();
  img.decoding = 'async';
  img.onload = () => SPRITE_CACHE.set(url, { img, ready: true });
  img.onerror = () => { SPRITE_CACHE.set(url, { img: null, ready: false }); };
  img.src = url;
  SPRITE_CACHE.set(url, { img: null, ready: false });
}

function drawImageCover(ctx, img, cx, cy, d) {
  const iw = img.videoWidth || img.naturalWidth || img.width;
  const ih = img.videoHeight || img.naturalHeight || img.height;
  const s = Math.max(d / iw, d / ih);
  const dw = iw * s, dh = ih * s;
  ctx.drawImage(img, cx - dw / 2, cy - dh / 2, dw, dh);
}

function drawCircleVideoScaledBuffered(ctx, video, cx, cy, d, scale) {
  // Prepare offscreen buffer
  const w = Math.ceil(d * scale);
  const h = w;
  if (overlayBuffer.width !== w || overlayBuffer.height !== h) {
    overlayBuffer.width = w;
    overlayBuffer.height = h;
  }
  // Draw video into buffer, covering the square
  overlayBufCtx.clearRect(0, 0, w, h);
  // Use same cover math as main, centered
  drawImageCover(overlayBufCtx, video, w / 2, h / 2, d * scale);

  // Draw buffered frame into clipped circle on main canvas
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, (d * scale) / 2, 0, Math.PI * 2);
  ctx.clip();
  ctx.drawImage(overlayBuffer, cx - w / 2, cy - h / 2);
  ctx.restore();
}

function drawOverlayPlaceholder(ctx, cx, cy, d, t, scale) {
  // Soft warm glow placeholder during fade (until video is ready)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, (d * scale) / 2, 0, Math.PI * 2);
  ctx.clip();
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, (d * scale) / 2);
  g.addColorStop(0, 'rgba(255,240,200,0.9)');
  g.addColorStop(0.4, 'rgba(255,220,140,0.45)');
  g.addColorStop(1, 'rgba(255,200,120,0.0)');
  ctx.fillStyle = g;
  ctx.fillRect(cx - d, cx - d, d * 2, d * 2);
  ctx.restore();
}

function drawGlowOutline(ctx, cx, cy, d, t, scale, alpha = 1) {
  const a = Math.max(0, Math.min(1, alpha));
  const r = (d / 2) * scale;
  // Ring 1 (soft glow) — bake alpha into colors; avoid relying on globalAlpha
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.shadowColor = `rgba(255, 230, 90, ${0.85 * a})`;
  ctx.shadowBlur = 18;
  ctx.lineWidth = 4;
  ctx.strokeStyle = `rgba(255, 255, 255, ${0.95 * a})`;
  ctx.stroke();
  ctx.restore();

  // Ring 2 (dashed highlight) — gradient with alpha baked in
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.setLineDash([10, 9]);
  ctx.lineDashOffset = -(t * 60);
  ctx.lineWidth = 2;
  const g = ctx.createLinearGradient(cx - r, cy, cx + r, cy);
  g.addColorStop(0, `rgba(255,255,255,${0.95 * a})`);
  g.addColorStop(1, `rgba(255,235,120,${0.95 * a})`);
  ctx.strokeStyle = g;
  ctx.stroke();
  ctx.restore();
}

/* ---------- node ---------- */
class Node {
  constructor(ax, ay, label, i) {
    this.anchor = createVector(ax, ay);
    this.pos = this.anchor.copy();
    this.offset = createVector(0, 0);
    this.vel = createVector(0, 0); // velocity for elastic motion
    this.acc = createVector(0, 0); // acceleration for elastic motion
    this.label = label;
    this.seed = random(1000);
    this.phase = random(TWO_PI) + i * 0.3;
    const u = SPRITES[label];
    this.spriteURL = u;
    if (u) { preloadSprite(u); }
  }
  update(t) {
    // Elastic spring physics
  const SPRING_STRENGTH = 0.04; // much tighter
  const DAMPING = 0.75; // much tighter

    // Target is anchor + orbit + noise + offset
    const ox = cos(this.phase + t * ORBIT_FREQ) * ORBIT_AMP;
    const oy = sin(this.phase * 0.85 + t * ORBIT_FREQ * 0.9) * ORBIT_AMP * 0.85;
    const nx = (noise(this.seed, (millis()) * NOISE_SPEED) - .5) * NOISE_AMP * 2;
    const ny = (noise(this.seed + 999, (millis()) * NOISE_SPEED) - .5) * NOISE_AMP * 2;
    const targetX = this.anchor.x + ox + nx + this.offset.x;
    const targetY = this.anchor.y + oy + ny + this.offset.y;

    // Spring force toward target
    let fx = (targetX - this.pos.x) * SPRING_STRENGTH;
    let fy = (targetY - this.pos.y) * SPRING_STRENGTH;
    this.acc.x = fx;
    this.acc.y = fy;

    // Integrate velocity and position
    this.vel.x = this.vel.x * DAMPING + this.acc.x;
    this.vel.y = this.vel.y * DAMPING + this.acc.y;
    this.pos.x += this.vel.x;
    this.pos.y += this.vel.y;

    // Slowly relax offset (so it doesn't accumulate)
    this.offset.x = lerp(this.offset.x, 0, OFFSET_RETURN);
    this.offset.y = lerp(this.offset.y, 0, OFFSET_RETURN);
  }
  draw() {
    const ctx = drawingContext, d = DOT_R * 2;
    const entry = this.spriteURL ? SPRITE_CACHE.get(this.spriteURL) : null;
    const hasSprite = entry && entry.ready && entry.img;

    ctx.save();
    // Only apply shadow for orbs other than 2025
    if (this.label !== "2025") {
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 20;
      ctx.shadowOffsetX = 5;
      ctx.shadowOffsetY = 5;
    }

    // NEW: if sprite not ready, draw nothing (remove blue fallback)
    if (!hasSprite) {
      ctx.restore();
      return;
    }

    // Draw sprite (keep 2025 unclipped if needed)
    const skipClip = this.label === "2025";
    if (!skipClip) {
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, DOT_R, 0, Math.PI * 2);
      ctx.clip();
    }
    const iw = entry.img.naturalWidth || entry.img.width,
          ih = entry.img.naturalHeight || entry.img.height;
    const s = Math.max(d / iw, d / ih);
    const dw = iw * s, dh = ih * s;
    ctx.drawImage(entry.img, this.pos.x - dw / 2, this.pos.y - dh / 2, dw, dh);

    ctx.restore();
  }
  isHover(mx, my) {
    return dist(mx, my, this.pos.x, this.pos.y) <= HOVER_R;
  }
}

/* ---------- setup ---------- */
function setup() {
  host = document.getElementById("uc-scroll-hero");
  readExtraBottom(); // read extra bottom before sizing canvas
  menuEl = document.getElementById("uc-orb-menu");
  menuCloseEl = menuEl.querySelector(".uc-menu-close");
  menuYearEl = menuEl.querySelector(".uc-menu-year");
  menuDescEl = menuEl.querySelector(".uc-menu-desc");
  menuLinkEl = menuEl.querySelector(".uc-menu-link");

  const r = host.getBoundingClientRect();
  cnv = createCanvas(r.width, r.height);
  cnv.parent("uc-canvas-mount");
  pixelDensity(2);
  frameRate(60);

  // Initialize media assets
  sphereImg = new Image();
  sphereImg.decoding = "async";
  sphereImg.src = SPHERE_TEXTURE_URL;

  ucLogo = new Image();
  ucLogo.decoding = "async";
  ucLogo.src = UC_LOGO_URL;

  // Preload lit sphere textures
  Object.entries(SPHERE_LIT_TEXTURES).forEach(([k, url]) => preloadLit(url, k));

  // Preload all per-year overlay videos
  Object.keys(OVERLAY_VIDEO_URLS).forEach(label => ensureOverlayVideo(label));

  // User-gesture fallback for stubborn Safari autoplay cases
  const kickstart = () => {
    OVERLAY_VIDEO_CACHE.forEach(({ video }, _label) => {
      video.play().catch(() => {});
    });
  };
  window.addEventListener("touchstart", kickstart, { once: true, passive: true });
  window.addEventListener("click", kickstart, { once: true });

  applyResponsive();

  // Seed anchor to avoid any initial (0,0) draw on first fade
  const baseH = window.innerHeight;
  overlayAnchor.x = width * LAYOUT.sphere.cx;
  overlayAnchor.y = baseH * LAYOUT.sphere.cy + CONTENT_OFFSET_Y;

  // Close menu (click X)
  menuCloseEl.addEventListener("click", hideMenu);

  // Initialize nodes via responsive setup
  applyResponsive();

  // Load 2026 pulse image
  orb2026PulseImg = new Image();
  orb2026PulseImg.decoding = "async";
  orb2026PulseImg.crossOrigin = "anonymous";
  orb2026PulseImg.referrerPolicy = "no-referrer";  // important for GitHub raw
  orb2026PulseImg.onload = async () => {
    try { await orb2026PulseImg.decode(); } catch {}
    orb2026PulseReady = true;
  };
  orb2026PulseImg.onerror = () => { orb2026PulseReady = false; };
  orb2026PulseImg.src = PULSE_2026.url;

  ['click','mousedown','mouseup','pointerdown','pointerup'].forEach(t => {
    menuEl.addEventListener(t, e => e.stopPropagation());
  });
  menuEl.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });
  menuEl.addEventListener('touchend',   e => e.stopPropagation());

  // Make the blue "Find more" button always open in a new tab (iOS-safe)
  menuLinkEl.addEventListener('click', (e) => {
    const href = menuLinkEl.getAttribute('href');
    if (!href || href === '#') return;
    e.stopPropagation();
    e.preventDefault();
    window.open(href, '_blank', 'noopener');
  });

  menuCarouselEl      = document.getElementById("uc-menu-carousel");
  menuCarouselTrackEl = document.getElementById("uc-carousel-track");
  menuCarouselDotsEl  = document.getElementById("uc-carousel-dots");

  // Nav buttons
  menuCarouselEl?.querySelector('.prev')?.addEventListener('click', (e) => { e.stopPropagation(); prevSlide(); });
  menuCarouselEl?.querySelector('.next')?.addEventListener('click', (e) => { e.stopPropagation(); nextSlide(); });

  // Pause on hover (desktop)
  menuCarouselEl?.addEventListener('mouseenter', () => stopCarousel());
  menuCarouselEl?.addEventListener('mouseleave', () => startCarousel());
}

function applyResponsive() {
  if (typeof useResponsiveLayout === "function") {
    useResponsiveLayout();
  }
  initNodes();
}

// Compute responsive sizes based on viewport height
function useResponsiveLayout() {
  const baseH = window.innerHeight;
  const DESIGN_H = 1080; // reference design height
  UNIT_SCALE = baseH / DESIGN_H;

  // Detect mobile and switch layout
  const mediaMobile = window.matchMedia('(max-width: 820px), (hover: none) and (pointer: coarse)').matches;
  const ratio = width / baseH; // canvas aspect
  IS_MOBILE = mediaMobile || (ratio < MOBILE_BREAK);
  LAYOUT = IS_MOBILE ? MOBILE_LAYOUT : DESKTOP_LAYOUT;

  // Orb sizes and interaction radii
  const DOT_R_BASE = 49;
  const HOVER_MARGIN_BASE = 10;
  DOT_R = DOT_R_BASE * UNIT_SCALE;
  HOVER_R = DOT_R + HOVER_MARGIN_BASE * UNIT_SCALE;

  // Lines, overlay, and drag distances
  LINE_WEIGHT = 2.0 * UNIT_SCALE;
  OVERLAY_SIZE = Math.round(DOT_R * 3.2);
  MAX_DRAG_DIST = 72 * UNIT_SCALE;
  MAX_OFFSET = 36 * UNIT_SCALE;

  // Make the popup menu 25% smaller than current
  const BASE_MENU_SCALE_DESKTOP = 0.49;
  const BASE_MENU_SCALE_MOBILE  = 0.42;
  const SHRINK_25 = 0.75; // 25% smaller
  MENU_SCALE = (IS_MOBILE ? BASE_MENU_SCALE_MOBILE : BASE_MENU_SCALE_DESKTOP) * SHRINK_25;

  // Optional: if you later want padding/close offsets to adjust with scale,
  // you can also set the CSS var here:
  // document.documentElement.style.setProperty('--menu-scale', MENU_SCALE);
}

function windowResized() {
  readExtraBottom();
  const r = host.getBoundingClientRect();
  resizeCanvas(r.width, r.height);
  applyResponsive();
}

function initNodes() {
  nodes = [];
  const w = width, h = window.innerHeight; // lock positions to viewport height
  Object.entries(LAYOUT.nodes).forEach(([label, [px, py]], i) => {
    nodes.push(new Node(px * w, py * h + CONTENT_OFFSET_Y, label, i));
  });
}

/* ---------- background & sphere/logo ---------- */
function drawBackground() {
  const ctx = drawingContext;
  // clear so CSS background is visible
  ctx.clearRect(0, 0, width, height);
  // optional semi-transparent gradient tint
  const g = ctx.createLinearGradient(0, 0, 0, height);
  g.addColorStop(0, 'rgba(255,120,0,0.0)');  // set to 0.0–0.6 to taste
  g.addColorStop(1, 'rgba(255,180,60,0.0)');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, width, height);
}

function drawSphereTextured() {
  const ctx = drawingContext;
  const baseH = window.innerHeight; // lock sphere size/pos to viewport height
  const r = Math.min(width, baseH) * LAYOUT.sphere.r;
  const cx = width * LAYOUT.sphere.cx;
  const cy = baseH * LAYOUT.sphere.cy + CONTENT_OFFSET_Y;
  const d = r * 2;

  if (sphereImg && sphereImg.complete) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.clip();

    const iw = sphereImg.naturalWidth || sphereImg.width;
    const ih = sphereImg.naturalHeight || sphereImg.height;
    const s = Math.max(d / iw, d / ih);
    const dw = iw * s, dh = ih * s;

    // Base sphere
    ctx.drawImage(sphereImg, cx - dw / 2, cy - dh / 2, dw, dh);

    // Crossfade lit textures: draw fading-out ones first, then current “in”
    // OUT queue (previously active labels)
    for (const o of fadingOut) {
      if (!(o.alpha > 0.001)) continue;
      const e2 = SPHERE_LIT_CACHE.get(o.label);
      if (e2 && e2.ready && e2.img) {
        const liw2 = e2.img.naturalWidth || e2.img.width;
        const lih2 = e2.img.naturalHeight || e2.img.height;
        const ls2 = Math.max(d / liw2, d / lih2);
        const ldw2 = liw2 * ls2, ldh2 = lih2 * ls2;
        ctx.globalAlpha = o.alpha;
        ctx.drawImage(e2.img, cx - ldw2 / 2, cy - ldh2 / 2, ldw2, ldh2);
        ctx.globalAlpha = 1;
      }
    }
    // IN (current label) — keep fading even when not hovering
    if (overlayIn.label) {
      const entryIn = SPHERE_LIT_CACHE.get(overlayIn.label);
      if (entryIn && entryIn.ready && entryIn.img) {
        const liw = entryIn.img.naturalWidth || entryIn.img.width;
        const lih = entryIn.img.naturalHeight || entryIn.img.height;
        const ls = Math.max(d / liw, d / lih);
        const ldw = liw * ls, ldh = lih * ls;
        const amt = Math.min(1, overlayIn.alpha);
        if (amt > 0.001) {
          ctx.globalAlpha = amt;
          ctx.drawImage(entryIn.img, cx - ldw / 2, cy - ldh / 2, ldw, ldh);
          ctx.globalAlpha = 1;
        }
      }
    }
    ctx.restore();
  } else {
   
    
  }

  // UC logo: 5% smaller & nudged downward
  if (ucLogo && ucLogo.complete) {
    const logoH = r * UC_LOGO_SCALE;
    const logoW = (ucLogo.naturalWidth / ucLogo.naturalHeight) * logoH;

    const x = cx - logoW / 2;
    const y = cy - logoH / 2 + (r * UC_LOGO_Y_OFFSET);

    const shadow = drawingContext;
    shadow.save();
    shadow.shadowColor = "rgba(0,0,0,0.35)";
    shadow.shadowBlur = 18;
    shadow.shadowOffsetY = 6;
    shadow.drawImage(ucLogo, x, y, logoW, logoH);
    shadow.restore();
  }
}

/* ---------- tug (touch-only) ---------- */
function findTouchedNode() {
  if (!draggingNode) { touchedNode = null; return; }
  const touchDist = DOT_R * TOUCH_DIST_MULT;
  let best = null, bestD = Infinity;
  for (const n of nodes) {
    if (n === draggingNode) continue;
    const d = dist(draggingNode.pos.x, draggingNode.pos.y, n.pos.x, n.pos.y);
    if (d <= touchDist && d < bestD) { best = n; bestD = d; } 
  }
  touchedNode = best || null;
}

function applyTouchTug() {
  if (!draggingNode || !touchedNode) return;
  const dx = draggingNode.pos.x - touchedNode.pos.x;
  const dy = draggingNode.pos.y - touchedNode.pos.y;
  const strength = 0.25;
  // Add a "charge" to the velocity for elastic swing
  touchedNode.vel.x += dx * strength * 0.22; // more charge
  touchedNode.vel.y += dy * strength * 0.22;
  // Removed tug area limit (MAX_OFFSET clamp)
}

function drawSelectiveTuggedLine(aNode, bNode) {
  const a = aNode.pos, b = bNode.pos;
  if (!draggingNode || !touchedNode || (aNode !== touchedNode && bNode !== touchedNode)) {
    line(a.x, a.y, b.x, b.y); return;
  }
  const ctx = drawingContext;
  const dp = draggingNode.pos;
  const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
  const cx = mx + (dp.x - mx) * LINE_TUG_CURVE;
  const cy = my + (dp.y - my) * LINE_TUG_CURVE;
  ctx.beginPath();
  ctx.moveTo(a.x, a.y);
  ctx.quadraticCurveTo(cx, cy, b.x, b.y);
  ctx.stroke();
}

// Draw popup connector with directional fade (orb → menu), length grows with progress
function drawMenuConnector(ctx, orbPos, menuPos, progress) {
  const clamped = Math.max(0, Math.min(1, progress));
  if (clamped <= 0.001) return;

  const dx = menuPos.x - orbPos.x;
  const dy = menuPos.y - orbPos.y;
  const px = orbPos.x + dx * clamped;
  const py = orbPos.y + dy * clamped;

  const grad = ctx.createLinearGradient(orbPos.x, orbPos.y, px, py);
  grad.addColorStop(0, `rgba(${CONNECTOR_COLOR}, 0)`);                 // start transparent at orb
  grad.addColorStop(1, `rgba(${CONNECTOR_COLOR}, ${CONNECTOR_ALPHA})`); // opaque toward menu

  ctx.save();
  ctx.strokeStyle = grad;
  ctx.lineWidth = LINE_WEIGHT;
  ctx.beginPath();
  ctx.moveTo(orbPos.x, orbPos.y);
  ctx.lineTo(px, py);
  ctx.stroke();
  ctx.restore();
}

/* ---------- draw ---------- */
function draw() {
  // Update menu position every frame if menu is pinned
  if (menuPinnedNode) {
    updateMenuPosition();
  }
  const t = (millis() / 1000);
  nodes.forEach(n => n.update(t));

  // Drag with deadzone + heavy response
  if (draggingNode) {
    if (!draggingActive) {
      const dx = mouseX - dragStart.x, dy = mouseY - dragStart.y;
      if (Math.hypot(dx, dy) > DRAG_DEADZONE) draggingActive = true;
    }
    if (draggingActive) {
      const anchor = draggingNode.anchor;
      const dx = mouseX - anchor.x;
      const dy = mouseY - anchor.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      const targetX = mouseX;
      const targetY = mouseY;

      const HEAVINESS = 0.1; // Adjust this value to make the orbs feel heavier
      draggingNode.pos.x += (targetX - draggingNode.pos.x) * HEAVINESS;
      draggingNode.pos.y += (targetY - draggingNode.pos.y) * HEAVINESS;

      const newDx = draggingNode.pos.x - anchor.x;
      const newDy = draggingNode.pos.y - anchor.y;
      const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);

      if (newDistance > MAX_DRAG_DIST) {
        const angle = Math.atan2(newDy, newDx);
        draggingNode.pos.x = anchor.x + Math.cos(angle) * MAX_DRAG_DIST;
        draggingNode.pos.y = anchor.y + Math.sin(angle) * MAX_DRAG_DIST;
      }
    }
  }

  findTouchedNode();
  applyTouchTug();

  drawBackground();
  if (!IS_MOBILE) drawSphereTextured(); // hide sphere on mobile

  const h = nodes.find(n => n.isHover(mouseX, mouseY)) || null;
  const isHovering = !!h && !menuPinnedNode; // Prevent hover if menu is open
  const isPinned = !!menuPinnedNode;
  const overlayShouldShow = isHovering || isPinned;

  if (isHovering) {
    draw.lastOverlayNode = h;
  } else if (isPinned) {
    draw.lastOverlayNode = menuPinnedNode;
  }

  // Anchor the overlay immediately when it should show to avoid (0,0) flicker
  if (overlayShouldShow && draw.lastOverlayNode && overlayIn.label) {
    overlayIn.anchor.x = draw.lastOverlayNode.pos.x;
    overlayIn.anchor.y = draw.lastOverlayNode.pos.y;
  }

  // Switch overlays: move current "in" to "out", start new "in" at alpha 0
  const desiredLabel = draw.lastOverlayNode ? draw.lastOverlayNode.label : null;
  if (desiredLabel !== overlayIn.label) {
    // Push current IN into the fadingOut queue (if any)
    if (overlayIn.label) {
      fadingOut.push({
        label: overlayIn.label,
        entry: overlayIn.entry,
        alpha: overlayIn.alpha,
        scale: overlayIn.scale,
        anchor: { x: overlayIn.anchor.x, y: overlayIn.anchor.y }
      });
    }

    if (desiredLabel) {
      overlayIn.label  = desiredLabel;
      overlayIn.entry  = ensureOverlayVideo(desiredLabel);
      overlayIn.alpha  = 0;
      overlayIn.scale  = OVERLAY_SCALE_OUT_TARGET; // start small, scale up fast
      if (draw.lastOverlayNode) {
        overlayIn.anchor.x = draw.lastOverlayNode.pos.x;
        overlayIn.anchor.y = draw.lastOverlayNode.pos.y;
      }
    } else {
      overlayIn.label = null;
      overlayIn.entry = null;
      overlayIn.alpha = 0;
    }
  }

  // Animate alphas/scales independently
  if (overlayIn.label) {
    overlayIn.alpha = lerp(overlayIn.alpha, overlayShouldShow ? 1 : 0, overlayShouldShow ? OVERLAY_FADE_IN : OVERLAY_FADE_OUT);
    overlayIn.scale = lerp(
      overlayIn.scale,
      overlayShouldShow ? OVERLAY_SCALE_IN_TARGET : OVERLAY_SCALE_OUT_TARGET,
      overlayShouldShow ? OVERLAY_SCALE_IN_SPEED : OVERLAY_SCALE_OUT_SPEED
    );
  }
  // Fade all “out” items
  for (const o of fadingOut) {
    o.alpha = lerp(o.alpha, 0, OVERLAY_FADE_OUT);
    o.scale = lerp(o.scale, OVERLAY_SCALE_OUT_TARGET, OVERLAY_SCALE_OUT_SPEED);
  }
  // Remove fully transparent ones
  for (let i = fadingOut.length - 1; i >= 0; i--) {
    if (fadingOut[i].alpha < 0.002) fadingOut.splice(i, 1);
  }

  strokeWeight(LINE_WEIGHT);
  stroke(255, 255, 255, LINE_ALPHA);
  const labelToNode = Object.fromEntries(nodes.map(n => [n.label, n]));
  const isReady = (n) => {
    const url = n && n.spriteURL;
    const e = url && SPRITE_CACHE.get(url);
    return !!(e && e.ready && e.img);
  };
  const drawn = new Set();
  Object.entries(CONNECTIONS).forEach(([from, tos]) => {
    tos.forEach(to => {
      const key = from < to ? `${from}-${to}` : `${to}-${from}`;
      if (drawn.has(key)) return;
      drawn.add(key);
      const aNode = labelToNode[from], bNode = labelToNode[to];
      if (!aNode || !bNode) return;
      if (!isReady(aNode) || !isReady(bNode)) return; // skip until both sprites ready
      drawSelectiveTuggedLine(aNode, bNode);
    });
  });

  noStroke();
  nodes.forEach(n => n.draw());

  // Draw 2026 pulse overlay LAST so it’s always visible on top
  draw2026PulseOverlay();

  // Popup connector animation: grow in when menu shows, fade when hiding
  const isShowing = menuEl && menuEl.classList.contains('show');
  const isHiding  = menuEl && menuEl.classList.contains('hiding');

  // Animate whenever showing, hiding, or still has residual progress
  const animatingConnector = (isShowing || isHiding || connectorProgress > 0.001);

  connectorProgress = lerp(
    connectorProgress,
    isShowing ? 1 : 0,
    isShowing ? CONNECTOR_GROW_IN : CONNECTOR_GROW_OUT
  );

  if (animatingConnector) {
    const ctx = drawingContext;

    // Live orb position if pinned, otherwise keep last cached
    let orbPosNow = menuPinnedNode ? { x: menuPinnedNode.pos.x, y: menuPinnedNode.pos.y } : null;
    if (orbPosNow) connectorCache.orb = orbPosNow;

    // Live menu center if it has layout (not fully hidden), else keep last cached
    let menuPosNow = null;
    if (menuEl) {
      const hostRect = host.getBoundingClientRect();
      const rect = menuEl.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        menuPosNow = {
          x: (rect.left - hostRect.left) + rect.width / 2,
          y: (rect.top  - hostRect.top)  + rect.height / 2
        };
      }
    }
    if (menuPosNow) connectorCache.menu = menuPosNow;

    const orbPos  = orbPosNow  || connectorCache.orb;
    const menuPos = menuPosNow || connectorCache.menu;

    if (orbPos && menuPos) {
      drawMenuConnector(ctx, orbPos, menuPos, connectorProgress);
    }
  }

  // Remove cursor logic for hovering
  if (draggingNode) {
    document.body.style.cursor = draggingActive ? 'grabbing' : 'default'; // Only show grabbing cursor while dragging
  } else {
    document.body.style.cursor = 'default'; // Default cursor for everything else
  }

  // Draw overlay videos ABSOLUTELY LAST: all OUT items first, then IN
  const ctx = drawingContext;
  if (fadingOut.length || (overlayIn.alpha > 0.001 && overlayIn.entry) || overlayShouldShow) {
    // OUT queue
    for (const o of fadingOut) {
      if (!(o.alpha > 0.001 && o.entry)) continue;
      ctx.save();
      ctx.globalAlpha = o.alpha;
      if (o.entry.ready && o.entry.video) {
        drawCircleVideoScaledBuffered(ctx, o.entry.video, o.anchor.x, o.anchor.y, OVERLAY_SIZE, o.scale);
      } else {
        drawOverlayPlaceholder(ctx, o.anchor.x, o.anchor.y, OVERLAY_SIZE, millis()/1000, o.scale);
      }
      drawGlowOutline(ctx, o.anchor.x, o.anchor.y, OVERLAY_SIZE, millis()/1000, o.scale, o.alpha);
      ctx.restore();
    }
    // IN layer
    if (overlayIn.alpha > 0.001 && overlayIn.entry) {
      ctx.save();
      ctx.globalAlpha = overlayIn.alpha;
      if (overlayIn.entry.ready && overlayIn.entry.video) {
        drawCircleVideoScaledBuffered(ctx, overlayIn.entry.video, overlayIn.anchor.x, overlayIn.anchor.y, OVERLAY_SIZE, overlayIn.scale);
      } else {
        drawOverlayPlaceholder(ctx, overlayIn.anchor.x, overlayIn.anchor.y, OVERLAY_SIZE, millis()/1000, overlayIn.scale);
      }
      drawGlowOutline(ctx, overlayIn.anchor.x, overlayIn.anchor.y, OVERLAY_SIZE, millis()/1000, overlayIn.scale, overlayIn.alpha);
      ctx.restore();
    }
  }
}

function drawPulseOverlay(cfg) {
  const nTarget = nodes.find(n => n.label === PULSE_YEAR);
  if (!nTarget) return;

  // NEW: delay logic (don’t draw anything before delay elapses)
  const delay = Math.max(0, cfg.delaySecs ?? 0);
  const tNow = millis() / 2000;
  if (tNow < delay) return;          // suppress even the debug dot
  const t = tNow - delay;            // offset timeline by delay

  const ax = nTarget.pos.x + (cfg.anchor?.dx ?? -0.72) * DOT_R;
  const ay = nTarget.pos.y + (cfg.anchor?.dy ??  0.72) * DOT_R;

  if (!orb2026PulseReady || !orb2026PulseImg) {
    const ctx = drawingContext;
    ctx.save();
    ctx.fillStyle = "rgba(255, 255, 0, 0.9)";
    ctx.beginPath();
    ctx.arc(ax, ay, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    return;
  }

  const secs = Math.max(0.001, cfg.secs || 1.5);
  const gap  = Math.max(0, cfg.gapSecs ?? cfg.gapsecs ?? 0);
  const total = secs + gap;
  const pAll = (t % total) / total;
  const activeFrac = secs / total;
  if (pAll >= activeFrac) return;

  const phase = pAll / activeFrac;

  const hold = Math.max(0, Math.min(1, cfg.hold || 0));
  let alphaPhase = 1;
  if (phase > hold) {
    const pf = (phase - hold) / (1 - hold);
    alphaPhase = 1 - pf;
  }
  const maxAlpha = Math.max(0, Math.min(1, cfg.alpha || 1));
  const alpha = alphaPhase * maxAlpha;

  const minS = cfg.min ?? 0.7, maxS = cfg.max ?? 1.6;
  const scale = minS + (maxS - minS) * phase;

  const iw = orb2026PulseImg.naturalWidth || orb2026PulseImg.width || 1;
  const ih = orb2026PulseImg.naturalHeight || orb2026PulseImg.height || 1;
  const aspect = ih / iw;
  const w = DOT_R * (cfg.base || 1.0) * scale;
  const h = w * aspect;

  const ctx = drawingContext;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.drawImage(orb2026PulseImg, ax - w / 2, ay - h / 2, w, h);
  ctx.restore();
}

function draw2026PulseOverlay() {
  drawPulseOverlay(PULSE_2026);     // bottom-left star
  drawPulseOverlay(PULSE_2026_TR);  // top-right star
}

/* ---------- interactions + menu ---------- */
function mousePressed() {
  const h = nodes.find((n) => n.isHover(mouseX, mouseY)) || null;

  if (h) {
    // Show or hide the menu for the clicked blue orb
    if (menuPinnedNode === h) {
      hideMenu();
    } else {
      showMenuAtNode(h);
    }
  } else {
    // If clicking outside any node, hide the menu
    hideMenu();
  }
}

function mouseReleased() {
  // Stop dragging without affecting the menu state
  draggingNode = null;
  draggingActive = false;
  touchedNode = null;
}

function touchStarted(e) {
  // Allow taps on menus/links; only handle touches that start on the canvas
  const tgt = e?.target || window.event?.target;
  const onCanvas = !!tgt && (tgt.closest('#uc-canvas-mount') || tgt.tagName.toLowerCase() === 'canvas');
  if (!onCanvas) return true; // DO NOT prevent default outside canvas

  const h = nodes.find(n => n.isHover(mouseX, mouseY)) || null;
  if (h) {
    draggingNode = h;
    draggingActive = false;
    dragStart = { x: mouseX, y: mouseY };
    // Show menu immediately when touch starts
    showMenuAtNode(h);
  }
  return false; // prevent default only for canvas touches (keeps drag smooth)
}

function touchEnded(e) {
  const tgt = e?.target || window.event?.target;
  const onCanvas = !!tgt && (tgt.closest('#uc-canvas-mount') || tgt.tagName.toLowerCase() === 'canvas');
  if (!onCanvas) return true; // allow default outside canvas

  draggingNode = null;
  draggingActive = false;
  touchedNode = null;
  return false;
}

/* Menu helpers */
function showMenuAtNode(node) {
  menuPinnedNode = node;

  menuYearEl.textContent = `${node.label} Esri User Conference`;
  const info = YEAR_INFO[node.label] || { desc: "No description available.", link: "" };
  const items = YEAR_DESC_ITEMS[node.label] || DEFAULT_DESC_ITEMS;

  menuDescEl.innerHTML = `
    <ul>
      <li class="uc-highlight">${info.desc}</li>
      ${items.map(it => `
        <li><a href="${it.href}" target="_blank" rel="noopener">${it.text}</a></li>
      `).join("")}
    </ul>
  `;

  const hasLink = !!(info.link && info.link !== "#");
  if (hasLink) {
    menuLinkEl.href = info.link;
    menuLinkEl.target = "_blank";
    menuLinkEl.rel = "noopener";
    menuLinkEl.style.display = "inline-flex";
  } else {
    menuLinkEl.style.display = "none";
  }

  menuEl.hidden = false;
  updateMenuPosition();
  menuEl.classList.remove('hiding');
  void menuEl.offsetWidth;
  menuEl.classList.add('show');

  // NEW: build and start the carousel for this node
  const gallery = YEAR_GALLERY[node.label] || DEFAULT_GALLERY;
  buildCarousel(gallery);
  startCarousel();
}

function hideMenu() {
  // Start fade-out: keep it visible but with opacity 0
  menuEl.classList.add('hiding');
  menuEl.classList.remove('show');

  const onEnd = (e) => {
    if (e.propertyName !== 'opacity') return;
    menuEl.removeEventListener('transitionend', onEnd);
    menuEl.hidden = true;           // finally hide after fade
    menuEl.classList.remove('hiding');
  };
  // In case transitionend doesn’t fire (older browsers)
  menuEl.addEventListener('transitionend', onEnd, { once: true });
  setTimeout(() => {
    if (!menuEl.hidden) {
      menuEl.hidden = true;
      menuEl.classList.remove('hiding');
    }
  }, 400); // > CSS 0.3s
  menuPinnedNode = null; // Release overlay pin

  stopCarousel();
}

// Update menu position to follow the pinned node
function updateMenuPosition() {
  if (!menuPinnedNode) return;
  const node = menuPinnedNode;

  menuEl.style.left = `${node.anchor.x}px`;
  menuEl.style.top  = `${node.anchor.y}px`;

  const placeMap = IS_MOBILE ? MOBILE_MENU_PLACEMENTS : MENU_PLACEMENTS;
  const place = placeMap[node.label] || { tx: -50, ty: -100, dx: 0, dy: 0 };
  const scale = Number.isFinite(MENU_SCALE) ? MENU_SCALE : 1;
  const anchorPercent = 40;

  // Apply scale first, then translations to keep position stable
  menuEl.style.transform =
    `scale(${scale}) translate(-${anchorPercent}%, -100%) translate(${place.tx}%, ${place.ty}%) translate(${place.dx}px, ${place.dy}px)`;
}

function createOverlayVideo(url) {
  const v = document.createElement("video");
  v.src = url;
  v.crossOrigin = "anonymous";
  v.preload = "auto";
  v.muted = true;
  v.setAttribute("muted", "");
  v.loop = true;
  v.playsInline = true;
  v.setAttribute("playsinline", "");
  v.autoplay = true;
  return v;
}

function ensureOverlayVideo(label) {
  if (!OVERLAY_VIDEO_URLS[label]) return null;
  if (OVERLAY_VIDEO_CACHE.has(label)) return OVERLAY_VIDEO_CACHE.get(label);
  const video = createOverlayVideo(OVERLAY_VIDEO_URLS[label]);
  const entry = { video, ready: false };
  const markReady = () => { entry.ready = true; video.play().catch(() => {}); };
  video.addEventListener("loadeddata", markReady, { once: true });
  video.addEventListener("canplay", markReady, { once: true });
  OVERLAY_VIDEO_CACHE.set(label, entry);
  return entry;
}

// Start fade-in 1s after the page finishes loading
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('uc-scroll-hero')?.classList.add('uc-stage-1');
  }, 1000);
});

// Handle bfcache (back/forward) restores
window.addEventListener('pageshow', (e) => {
  if (e.persisted) {
    setTimeout(() => {
      document.getElementById('uc-scroll-hero')?.classList.add('uc-stage-1');
    }, 1000);
  }
});

// --- Carousel helpers ---
function buildCarousel(images) {
  if (!menuCarouselTrackEl) return;
  menuCarouselTrackEl.innerHTML = "";
  images.forEach(src => {
    const img = new Image();
    img.decoding = "async";
    img.alt = "";
    img.src = src;
    menuCarouselTrackEl.appendChild(img);
  });
  // dots
  if (menuCarouselDotsEl) {
    menuCarouselDotsEl.innerHTML = "";
    images.forEach((_, i) => {
      const b = document.createElement('button');
      b.addEventListener('click', (e) => { e.stopPropagation(); goToSlide(i); });
      menuCarouselDotsEl.appendChild(b);
    });
  }
  carouselIdx = 0;
  applyCarouselTransform();
  updateDots();
}

function applyCarouselTransform() {
  if (!menuCarouselTrackEl) return;
  menuCarouselTrackEl.style.transform = `translateX(${-carouselIdx * 100}%)`;
}
function updateDots() {
  if (!menuCarouselDotsEl) return;
  [...menuCarouselDotsEl.children].forEach((d, i) => {
    d.classList.toggle('active', i === carouselIdx);
  });
}
function goToSlide(i) {
  const total = menuCarouselTrackEl ? menuCarouselTrackEl.children.length : 0;
  if (!total) return;
  carouselIdx = ((i % total) + total) % total;
  applyCarouselTransform();
  updateDots();
}
function nextSlide() { goToSlide(carouselIdx + 1); }
function prevSlide() { goToSlide(carouselIdx - 1); }
function startCarousel() {
  stopCarousel();
  const total = menuCarouselTrackEl ? menuCarouselTrackEl.children.length : 0;
  if (total > 1) carouselTimer = setInterval(nextSlide, CAROUSEL_INTERVAL_MS);
}
function stopCarousel() {
  if (carouselTimer) { clearInterval(carouselTimer); carouselTimer = null; }
}
</script>